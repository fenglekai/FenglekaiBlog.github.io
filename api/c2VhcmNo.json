[{"title":"Electron构建桌面应用","date":"2023-02-22T03:52:25.000Z","date_formatted":{"ll":"2023年2月22日","L":"2023/02/22","MM-DD":"02-22"},"updated":"2023-02-22T03:54:27.334Z","content":"为解决前端部署到其他主机复杂步骤（比如：docker部署，nginx部署），直接构建桌面应用打开即用，用户操作简单便捷的部署方案。\n基于react-big-screen框架二次开发构建\n使用环境\n\n本机使用的是Deepin 20.6，基于Debian 10.10底层。\nNode 12.22.12\nReact 16.2.0\ndata-view-react 1.2.4\nElectron 11.5.0\nElectron-builder 22.10.5\nwine 7.0\n\n开始构建\n\nElectron官方文档：https://www.electronjs.org/zh/docs/latest/\n\n安装依赖\n12npm install -D electron@11.5.0npm install -D electron-builder@22.10.5\n这里主要是为了配合之前项目框架的Node版本做了匹配，高版本会出现很多错误。\n创建Electron入口文件\n参考网上教程创建main.js在根目录\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 引入electron并创建一个Browserwindowconst &#123; app, BrowserWindow &#125; = require(&quot;electron&quot;);const path = require(&quot;path&quot;);const url = require(&quot;url&quot;);// 获取在 package.json 中的命令脚本传入的参数，来判断是开发还是生产环境const mode = process.argv[2];// 保持window对象的全局引用,避免JavaScript对象被垃圾回收时,窗口被自动关闭.let mainWindow;function createWindow() &#123;  //创建浏览器窗口,宽高自定义  mainWindow = new BrowserWindow(&#123;    width: 800,    height: 600,  &#125;);  mainWindow.on(&quot;resize&quot;, () =&gt; &#123;    mainWindow.reload();  &#125;);  if (mode === &quot;dev&quot;) &#123;    // 加载应用----适用于 react 项目    mainWindow.loadURL(&quot;http://localhost:9001/&quot;);  &#125; else &#123;    // 加载应用-----react项目打包后的路径    mainWindow.loadURL(      url.format(&#123;        pathname: path.join(__dirname, &quot;./dist/index.html&quot;),        protocol: &quot;file:&quot;,        slashes: true,      &#125;)    );  &#125;  // 打开开发者工具，默认不打开  // mainWindow.webContents.openDevTools()  // 关闭window时触发下列事件.  mainWindow.on(&quot;closed&quot;, function () &#123;    mainWindow = null;  &#125;);&#125;// 当 Electron 完成初始化并准备创建浏览器窗口时调用此方法app.on(&quot;ready&quot;, createWindow);// 所有窗口关闭时退出应用.app.on(&quot;window-all-closed&quot;, function () &#123;  // macOS中除非用户按下 `Cmd + Q` 显式退出,否则应用与菜单栏始终处于活动状态.  if (process.platform !== &quot;darwin&quot;) &#123;    app.quit();  &#125;&#125;);app.on(&quot;activate&quot;, function () &#123;  // macOS中点击Dock图标时没有已打开的其余应用窗口时,则通常在应用中重建一个窗口  if (mainWindow === null) &#123;    createWindow();  &#125;&#125;);\n修改package.json文件\n新增几个关键项\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123;  &quot;name&quot;: &quot;project name&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;homepage&quot;: &quot;./&quot;,  &quot;main&quot;: &quot;main.js&quot;,  &quot;scripts&quot;: &#123;    &quot;electron-start&quot;: &quot;electron . dev&quot;,    &quot;electron&quot;: &quot;electron .&quot;,    &quot;build-win64&quot;: &quot;electron-builder --win --x64&quot;,    &quot;build-linux&quot;: &quot;electron-builder --linux&quot;,    &quot;build-mac&quot;: &quot;electron-builder --mac&quot;  &#125;,  &quot;build&quot;: &#123;    &quot;productName&quot;: &quot;productName&quot;,    &quot;appId&quot;: &quot;appId&quot;,    &quot;copyright&quot;: &quot;&quot;,    &quot;directories&quot;: &#123;      &quot;buildResources&quot;: &quot;./&quot;,      &quot;output&quot;: &quot;build&quot;    &#125;,    &quot;files&quot;: [      &quot;dist/**/*&quot;,      &quot;node_modules/**/*&quot;,      &quot;main.js&quot;    ],    &quot;win&quot;: &#123;      &quot;icon&quot;: &quot;./dist/favicon.ico&quot;,      &quot;target&quot;: [        &quot;nsis&quot;      ]    &#125;,    &quot;linux&quot;: &#123;      &quot;icon&quot;: &quot;./dist/icon.png&quot;    &#125;,    &quot;mac&quot;: &#123;      &quot;icon&quot;: &quot;./dist/icon.png&quot;    &#125;,    &quot;nsis&quot;: &#123;      &quot;installerIcon&quot;: &quot;dist/favicon.ico&quot;,      &quot;uninstallerIcon&quot;: &quot;dist/favicon.ico&quot;,      &quot;uninstallDisplayName&quot;: &quot;卸载这个软件&quot;,      &quot;oneClick&quot;: false,      &quot;allowToChangeInstallationDirectory&quot;: true,      &quot;allowElevation&quot;: true,      &quot;createDesktopShortcut&quot;: true    &#125;  &#125;&#125;\n运行项目\n开发模式\n需要开启两个命令窗口\n1npm run start\n这里注意要修改main.js下的mainWindow.loadURL(&quot;http://localhost:9001/&quot;);需要修改成你正在运行项目的端口\n1npm run electron-start\n预览模式\n首先打包react项目\n1npm run build\n这里也是需要注意对应打包文件的路径pathname: path.join(__dirname, &quot;./dist/index.html&quot;),\n1npm run electron\n构建打包应用\n这里使用的electron-builder，原因是与electron-force和electron-packager比较下npm周下载量多。\n123456# windowsnpm run build-win64# linuxnpm run build-linux# macnpm run build-mac\n通过相应的命令可以构建出对应系统的应用，mac的构建还未尝试过，有需要的可以去找相关教程。\n打包需要的配置主要是在package.json下的build字段,上面已经贴出配置了。需要注意的是ico格式转换和大小问题。\nwine安装教程\n打包exe文件使用到的应用\n\ndeepin20.6安装wine7.0\n\n这篇文章教程非常详细，按照步骤安装就行。\n遇到问题\n\nico文件不能通过png文件直接替换后缀。需要找个在线生成ico进行转换\nLinux，Mac使用png格式的icon\nicon大小需要256 x 256\nLinux下的exe文件只能在~/.wine/drive_c目录下运行\n\n","thumbnail":"https://picsum.photos/1280/720?random=20230222","color":"#111","plink":"https://fenglekai.github.io/2023/02/22/Electron构建桌面应用/"},{"title":"前端SEO优化","date":"2023-02-13T08:28:59.000Z","date_formatted":{"ll":"2023年2月13日","L":"2023/02/13","MM-DD":"02-13"},"updated":"2023-02-13T08:29:13.583Z","content":"SEO常见的技术优化手段通常是针对于搜索引擎爬虫的，通过建立一系列约定的规则或手段来使得搜索引擎更好地抓取到网站的信息。\ntitle标签\n1&lt;title&gt;这里填写标题&lt;/title&gt; \n\n一个页面使用一个不重复的标题\n简单精准，避免通用模糊\n突出搜索意图\n\nmeta标签\ndescription\n1&lt;meta name=&quot;description&quot; content=&quot;这里填写描述&quot;&gt; \n\n一个页面使用一个独立的描述\n控制内容长度，少于160个字符\n\nrobots\n1234567891011&lt;head&gt;   &lt;meta name=”robots” content=&quot;$&#123;content&#125;&quot;&gt; &lt;/head&gt;  &lt;!-- content可选：index | noindex | follow | nofollowindex: 告诉搜索引擎收录我 noindex：告诉搜索引擎不要收录我 follow：告诉搜索引擎爬取页面的links nofollow：告诉搜索引擎不要爬取页面的links如果不设置此标签，等同于content=&quot;index, follow&quot;  --&gt; \nbody内容\n\n\n标题：分级恰当，层级关系明确（标签：h1、h2、h3），标题含义明确\n\n\n文件名称语义化：img文件名称最好是有语义的，能标识该图片内容的\n\n\n图片说明 alt-tag：img标签的alt属性值不能空，要填写该图片的描述\n1&lt;img src=&quot;huyou.jpg&quot; alt=&quot;xxxx&quot;&gt; \n\n\n语义化链接\n\nbad case：www.example.com/?p=123456\ngood case：www.example.com/topic-name\n\n提升网站速度\n测速工具：\nhttps://developers.google.com/speed/pagespeed/insights/\n信息提供\nsitemaps网站地图\n提供给搜索引擎网站地图信息的协议，通过它可以告知搜索引擎关键path信息，类似网站的目录，可以手动配置，也可以使用生成器自动生成：https://www.xml-sitemaps.com/\n\n配置生成后放到网站根目录\n\n","thumbnail":"https://picsum.photos/1280/720?random=1","color":"#111","plink":"https://fenglekai.github.io/2023/02/13/前端SEO优化/"},{"title":"前端数据埋点方案","date":"2023-02-13T08:28:04.000Z","date_formatted":{"ll":"2023年2月13日","L":"2023/02/13","MM-DD":"02-13"},"updated":"2023-02-13T08:28:40.171Z","content":"为了实现统计访客浏览、停留时间以及页面等操作。在访问量大，操作频繁的页面进行优化。根据分析出来的结果辅助产品优化、迭代、以及新需求的开发。\n\n参考自稀土掘金文章https://juejin.cn/post/7094146488439144455\n简单实现 https://juejin.cn/post/7047710777507053582\n\n一些名词\nUV（Unique Visitor）\n通过互联网访问、浏览这个网页的自然人。访问网站的一台电脑客户端为一个访客。0-24小时内相同的客户端只被计算一次。一天内同个访客多次访问仅计算一个UV\nIP（Internet Protocol）\n访问过站点的IP总数，以用户的IP地址作为统计依据。0-24小时内相同IP地址只被计算一次\n\n如：你和你的家人用各自的账号在同一台电脑上登录新浪微博，则IP数+1，UV数+2。由于使用的是同一台电脑，所以IP不变，但使用的不同账号，所以UV+2\n\nPV（Page View）\n即页面浏览量或点击量，用户每一次对网站中每个网页访问均被纪录一个PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。\nVV（Visit View）\n统计所有访客一天内访问站点的次数。当访客完成所有浏览并关掉网站页面完成一次访问，同一访客一天内可能有多次访问行为，访问次数累计。\n埋点方案\n代码埋点\n用户触发某个动作后手动上报数据 优点：是最准确的，可以满足很多定制化的需求。 缺点：埋点逻辑与业务代码耦合到一起，不利于代码维护和复用。\n可视化埋点\n通过可视化工具配置采集节点，指定自己想要监测的元素和属性。核心是查找 dom 然后绑定事件，业界比较有名的是 Mixpanel、GrowingIO、神策 优点：可以做到按需配置，又不会像全埋点那样产生大量的无用数据。 缺点：比较难加载一些运行时参数；页面结构发生变化的时候，可能就需要进行部分重新配置。\n无痕埋点（全埋点）\n前端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据 优点：收集用户的所有端上行为，很全面。 缺点：无效的数据很多、上报数据量大。\n案例参考引用链接\n","thumbnail":"https://picsum.photos/1280/720?random=16","color":"#111","plink":"https://fenglekai.github.io/2023/02/13/前端数据埋点方案/"},{"title":"Unicode编码顺序","date":"2023-02-13T08:26:18.000Z","date_formatted":{"ll":"2023年2月13日","L":"2023/02/13","MM-DD":"02-13"},"updated":"2023-02-13T08:26:47.250Z","content":"\n\n0020\n\n!\n&quot;\n#\n$\n%\n&amp;\n’\n(\n)\n*\n+\n,\n-\n.\n/\nNumber\n\n\n\n\n0030\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n:\n;\n&lt;\n=\n&gt;\n?\nNumber\n\n\n0040\n@\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nAlphabet\n\n\n0050\nP\nQ\nR\nS\nT\nU\nV\nW\nX\nY\nZ\n[\n\\\n]\n^\n_\nAlphabet\n\n\n0060\n`\na\nb\nc\nd\ne\nf\ng\nh\ni\nj\nk\nl\nm\nn\no\n\n\n\n0070\np\nq\nr\ns\nt\nu\nv\nw\nx\ny\nz\n{\n|\n}\n~\n\n\n\n\n列出U+0020~U+007F的顺序\n编码为16进制：0020-0029-002A-002F共16位\n","thumbnail":"https://picsum.photos/1280/720?random=15","color":"#111","plink":"https://fenglekai.github.io/2023/02/13/Unicode编码顺序/"},{"title":"Nginx配置","date":"2023-02-13T08:19:47.000Z","date_formatted":{"ll":"2023年2月13日","L":"2023/02/13","MM-DD":"02-13"},"updated":"2023-02-13T08:21:26.594Z","content":"vue打包文件刷新页面返回nginx 404\n123456789# 刷新页面返回nginx 404,nginx location / 配置try_files $uri $uri/ /index.html;# 若打包文件不在根目录需添加配置location ^~/A &#123;    alias /XX/A;//此处为A的路径    index index.html;    try_files $uri $uri/ /A/index.html;&#125;\n配置数据库,ssh反向代理\n12345678910111213141516stream &#123;            upstream oracle &#123;           server 192.168.21.213:1521 weight=1 max_fails=2 fail_timeout=30s;   #原oracle地址    &#125;     server &#123;        listen       3335;# 反向代理后监听的端口,nginx启动后访问192.168.21.100:3335就可以访问到oracleA        proxy_connect_timeout 1s;        proxy_timeout 3s;        proxy_pass oracle;    &#125;————————————————版权声明：本文为CSDN博主「lightingZZ」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u014265442/article/details/114932253\n","thumbnail":"https://picsum.photos/1280/720?random=14","color":"#111","plink":"https://fenglekai.github.io/2023/02/13/Nginx配置/"},{"title":"Ubuntu命令","date":"2023-02-13T08:11:54.000Z","date_formatted":{"ll":"2023年2月13日","L":"2023/02/13","MM-DD":"02-13"},"updated":"2023-02-13T08:13:40.039Z","content":"System limit for number of file watchers reached\n解决：\n1echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p\n修改目录权限\n12341.更改目录所有者命令:chown -R 用户名称 目录名称2.更改目录权限命令:chmod -R 755 目录名称\napt-get代理设置\n12# /etc/apt/apt.confAcquire::http::proxy &quot;http://username:password@ip:port/&quot;;\n设置bash代理\n12# ~/.bashrcexport HTTP_PROXY=http://username:password@ip:port\n更新系统\n12yum update -y# /var没有空间可以更改/etc/yum.conf文件下的缓存目录\n防火墙开启/关闭端口\n12345678# 关闭端口号iptables -A OUTPUT -p tcp --dport 端口号-j DROP# 开启端口号iptables -A INPUT -ptcp --dport  端口号-j ACCEPT# 保存service iptables save# 查看端口状态netstat -tunlp\ntree命令\n123456# 以树形结果输出目录# -d 只显示目录# -L Level 限制深度层级# -I file 需要忽略的文件# &gt; file 输出到文件tree -d -L 3 -I &quot;node_modules|.git|dist|&quot; &gt; ./tree.txt\n删除匹配文件\n1sudo rm $(find ./ -name &#x27;10.124.131*&#x27;)\n查看占用端口\n1netstat -anp | grep 8000\n设定有线无线网络共用\n123route -nsudo route add default gw 192.168.43.1sudo route add -net 10.0.0.0 netmask 255.0.0.0 gw 10.161.8.1 dev enp2s0\n更新蓝牙驱动\n1sudo apt install bluetooth blueman\n禁止/启用中键粘贴\n1234# 禁止xmodmap -e &quot;pointer = 1 25 3 4 5 6 7 8&quot;# 启用xmodmap -e &quot;pointer = 1 2 3 4 5 6 7 8&quot;\n重启网络服务\n1sudo service network-manager restart\n修改本地时区\n12sudo timedatectl set-timezone Asia/Shanghaisudo timedatectl set-local-rtc 1\n","thumbnail":"https://picsum.photos/1280/720?random=13","color":"#111","plink":"https://fenglekai.github.io/2023/02/13/Ubuntu命令/"},{"title":"Canvas拖拽和缩放","date":"2023-02-13T08:00:27.000Z","date_formatted":{"ll":"2023年2月13日","L":"2023/02/13","MM-DD":"02-13"},"updated":"2023-02-13T08:13:32.699Z","content":"Vue实现版本\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175&lt;template&gt;  &lt;div    ref=&quot;mapWrapper&quot;    class=&quot;relative overflow-hidden w-full&quot;    style=&quot;height: 68vh&quot;  &gt;    &lt;canvas ref=&quot;mapFactory&quot; style=&quot;cursor: grab&quot;&gt;&lt;/canvas&gt;    &lt;div class=&quot;absolute bottom-0 right-0&quot;&gt;      &lt;el-button type=&quot;primary&quot; @click=&quot;resetMap&quot;&gt;reset&lt;/el-button&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;mapCanvas&quot;,  data() &#123;    return &#123;      WIDTH: 0,      HEIGHT: 0,      scale: 1,      current: &#123;        x: 0,        y: 0,        width: 0,        height: 0,      &#125;,      move: false,      moveBefore: &#123; x: 0, y: 0 &#125;,    &#125;;  &#125;,  mounted() &#123;    this.initCanvas();  &#125;,  methods: &#123;    limit(min, max) &#123;      return (val) =&gt; Math.min(Math.max(val, min), max);    &#125;,    loadImage() &#123;      return new Promise((resolve) =&gt; &#123;        const mapImg = new Image();        mapImg.src = `$&#123;require(&quot;assets/3F(6.197565,11.6)(129.2361,73.1).png&quot;)&#125;`;        mapImg.addEventListener(&quot;load&quot;, () =&gt; resolve(mapImg));        mapImg.addEventListener(&quot;error&quot;, () =&gt; resolve(null));      &#125;);    &#125;,    // canvas缩放    async zoom(position) &#123;      const mapFactory = this.$refs.mapFactory;      const mapContext = mapFactory.getContext(&quot;2d&quot;);      // 加载图片      const img = await this.loadImage();      if (!img) return;      mapContext.clearRect(0, 0, this.WIDTH, this.HEIGHT);      const origin = &#123;        x: position.x - this.current.x,        y: position.y - this.current.y,      &#125;;      const newWidth = this.WIDTH * this.scale;      const newHeight = this.HEIGHT * this.scale;      const dx =        this.current.x +        (origin.x - (origin.x / this.current.width) * newWidth);      const dy =        this.current.y +        (origin.y - (origin.y / this.current.height) * newHeight);      this.current.x = dx;      this.current.y = dy;      this.current.width = newWidth;      this.current.height = newHeight;      mapContext.drawImage(img, dx, dy, newWidth, newHeight);    &#125;,    // canvas开始移动    canvasDown(e) &#123;      const mapFactory = this.$refs.mapFactory;      mapFactory.style.cursor = &quot;grabbing&quot;;      this.move = true;      const mousePos = this.getCanvasMousePos(e);      this.moveBefore = &#123; ...mousePos &#125;;    &#125;,    // canvas移动中    async canvasMove(e) &#123;      if (this.move) &#123;        const mousePos = this.getCanvasMousePos(e);        const mapFactory = this.$refs.mapFactory;        const mapContext = mapFactory.getContext(&quot;2d&quot;);        // 加载图片        const img = await this.loadImage();        if (!img) return;        mapContext.clearRect(0, 0, this.WIDTH, this.HEIGHT);        this.current.x += mousePos.x - this.moveBefore.x;        this.current.y += mousePos.y - this.moveBefore.y;        this.moveBefore = &#123; ...mousePos &#125;;        mapContext.drawImage(          img,          this.current.x,          this.current.y,          this.current.width,          this.current.height        );      &#125;    &#125;,    // canvas结束移动    canvasUp() &#123;&#125;,    /**     * @description: 鼠标坐标转换,将鼠标点的位置，转换为canvas元素内部点击的位置     * @param &#123;*&#125; e 鼠标事件     * @return &#123;*&#125;     */    getCanvasMousePos(e) &#123;      const mapFactory = this.$refs.mapFactory;      let rect = mapFactory.getBoundingClientRect();      let x = ((e.clientX - rect.left) * mapFactory.width) / rect.width;      let y = ((e.clientY - rect.top) * mapFactory.height) / rect.height;      return &#123;        x: x,        y: y,      &#125;;    &#125;,    initCanvas() &#123;      const mapWrapper = this.$refs.mapWrapper;      const mapFactory = this.$refs.mapFactory;      this.WIDTH = mapFactory.width = mapWrapper.clientWidth;      this.HEIGHT = mapFactory.height = mapWrapper.clientHeight;      this.current = &#123; x: 0, y: 0, width: this.WIDTH, height: this.HEIGHT &#125;;      this.zoom(&#123; x: 0, y: 0 &#125;);      // 中键缩放事件      mapFactory.addEventListener(&quot;mousewheel&quot;, (e) =&gt; &#123;        e.preventDefault();        const direction = this.limit(-1, 1)(e.deltaY || e.detail);        this.scale -= direction * 0.5;        if (this.scale &lt; 1) return (this.scale = 1);        let mousePos = this.getCanvasMousePos(e);        this.zoom(mousePos);      &#125;);      // 鼠标点下事件      mapFactory.addEventListener(&quot;mousedown&quot;, (e) =&gt; &#123;        e.preventDefault();        this.canvasDown(e);      &#125;);      // 鼠标移动事件      mapFactory.addEventListener(&quot;mousemove&quot;, (e) =&gt; &#123;        e.preventDefault();        this.canvasMove(e);      &#125;);      // 鼠标松开事件      mapFactory.addEventListener(&quot;mouseup&quot;, (e) =&gt; &#123;        e.preventDefault();        mapFactory.style.cursor = &quot;grab&quot;;        this.move = false;      &#125;);      // 鼠标离开事件      mapFactory.addEventListener(&quot;mouseleave&quot;, (e) =&gt; &#123;        e.preventDefault();        mapFactory.style.cursor = &quot;grab&quot;;        this.move = false;      &#125;);    &#125;,    resetMap() &#123;      this.scale = 1;      this.current.x = 0;      this.current.y = 0;      this.current.width = this.WIDTH;      this.current.height = this.HEIGHT;      this.zoom(&#123; x: 0, y: 0 &#125;);    &#125;,  &#125;,&#125;;&lt;/script&gt;\n借鉴源码\n缩放\n\ncodepen：https://codepen.io/xty1992a/pen/gOOjoqK?editors=0010\n\n拖拽\n\nhttps://blog.csdn.net/y396397735/article/details/117692565\n\n","thumbnail":"https://picsum.photos/1280/720?random=12","color":"#111","plink":"https://fenglekai.github.io/2023/02/13/Canvas拖拽和缩放/"},{"title":"前端文件上传与下载","date":"2022-06-27T01:13:37.000Z","date_formatted":{"ll":"2022年6月27日","L":"2022/06/27","MM-DD":"06-27"},"updated":"2023-02-13T07:34:07.829Z","content":"HTML文件上传\n12345678&lt;input  ref=&quot;select&quot;  type=&quot;file&quot;  class=&quot;form&quot;  hidden  accept=&quot;application/dxf&quot;  multiple=&quot;multiple&quot;/&gt;\n\ntype控制input类型\nhidden控制元素显示隐藏\naccept控制上传类型\nmultiple是否可以多选\n\n文件上传进度条\n1234567891011// 在axios下配置request HeaderonUploadProgress: (progressEvent) =&gt; &#123;    if(progressEvent.lengthComputable)&#123;        let complete =             (((progressEvent.loaded / progressEvent.total) * 100) | 0);        this.percentage = complete;        if (complete === 100) &#123;            this.percentage = 0 // 重置进度        &#125;    &#125;&#125;\n文件下载\n1234567891011121314151617181920// 文件链接直接下载const a = document.createElement(&quot;a&quot;);const url = &quot;url&quot;;const fileName = &quot;filename.xlsx&quot;;a.herf = url;a.download = fileName;a.click();// 后端blob流文件下载fetch(url).then((response) =&gt;  response.blob().then((blob) =&gt; &#123;    const a = document.createElement(&quot;a&quot;);    const url = window.URL.createObjectURL(blob);    const fileName = &quot;filename.xlsx&quot;;    a.herf = url;    a.download = fileName;    a.click();    window.URL.revokeObjectURL(url);  &#125;));\n","thumbnail":"https://picsum.photos/1280/720?random=11","color":"#111","plink":"https://fenglekai.github.io/2022/06/27/前端文件上传与下载/"},{"title":"学习路上的坑","date":"2022-06-27T01:02:02.000Z","date_formatted":{"ll":"2022年6月27日","L":"2022/06/27","MM-DD":"06-27"},"updated":"2023-02-22T03:53:32.602Z","content":"mockjs的坑\n123// 在 node_modules/mockjs/dist/mock.js 中的 // 如果未找到匹配的数据模板 上面加入以下代码 MockXMLHttpRequest.prototype.upload = createNativeXMLHttpRequest().upload\n原因是 Mockjs 中, 封装了原生的 XMLHttpRequest 为 MockXMLHttpRequest. 解决思路是, 把原生 XMLHttpRequest 的 upload 属性赋给 MockXMLHttpRequest 的原型对象\n后来发现还是解决不了问题，最简单的办法还是删除mockjs依赖…\ncommand:  node scripts/build.js\n主要是windows平台缺少编译环境，\n\n1、先运行： npm install -g node-gyp\n2、然后运行：运行 npm install --global --production windows-build-tools\n\n可以自动安装跨平台的编译器\n12npm uninstall node-sassnpm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/\n接着就可以\n\nnpm install\nnpm run dev\n\nvite+vue3+ts 使用@别名的一些问题\n首先需要在vite.config.js中配置\n12345678910111213141516171819import &#123;  defineConfig&#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;const &#123;  resolve&#125; = require(&#x27;path&#x27;);export default defineConfig(&#123;  resolve: &#123;    alias: &#123;      &#x27;@&#x27;: resolve(__dirname, &#x27;src&#x27;),    &#125;,    extensions: [&quot;.js&quot;, &quot;.ts&quot;, &quot;.tsx&quot;, &quot;.jsx&quot;]  &#125;,    plugins: [vue()]&#125;)\n然后新建tsconfig.json配置\n1234567891011121314151617181920212223242526272829303132333435363738&#123;    &quot;compilerOptions&quot;: &#123;        &quot;target&quot;: &quot;esnext&quot;,        &quot;module&quot;: &quot;esnext&quot;,        &quot;strict&quot;: true,        &quot;jsx&quot;: &quot;preserve&quot;,        &quot;importHelpers&quot;: true,        &quot;moduleResolution&quot;: &quot;node&quot;,        &quot;skipLibCheck&quot;: true,        &quot;esModuleInterop&quot;: true,        &quot;allowSyntheticDefaultImports&quot;: true,        &quot;sourceMap&quot;: true,        &quot;baseUrl&quot;: &quot;.&quot;,        &quot;types&quot;: [&quot;vite/client&quot;],        &quot;paths&quot;: &#123;            &quot;@/*&quot;: [                &quot;src/*&quot;            ]        &#125;,        &quot;lib&quot;: [            &quot;esnext&quot;,            &quot;dom&quot;,            &quot;dom.iterable&quot;,            &quot;scripthost&quot;        ]    &#125;,    &quot;include&quot;: [        &quot;src/**/*.ts&quot;,        &quot;src/**/*.tsx&quot;,        &quot;src/**/*.vue&quot;,        &quot;tests/**/*.ts&quot;,        &quot;tests/**/*.tsx&quot;,        &quot;typings&quot;    ],    &quot;exclude&quot;: [        &quot;node_modules&quot;    ]&#125;\n最后解决ts不能识别.vue文件的问题\n根目录新建文件夹typings，新建文件shims-vue.d.ts\n12345declare module &#x27;*.vue&#x27; &#123;// ts全局定义.vue文件判断    import type &#123; DefineComponent &#125; from &#x27;vue&#x27;    const component: DefineComponent&lt;&#123;&#125;, &#123;&#125;, any&gt;    export default component&#125;\nvite打包后访问白屏、跨域报错问题\n在vite.config.js添加base: './' \n来自vue issues silentdepth的回答：\n\n那我建议你换别的 bundler。Vite 没有为传统模块系统设计，ES Modules 是其特性基线。\n或者，你可以在原生应用注入自定义 scheme 来使用内嵌页面（example-app:// 什么的），这样可以正常激活 ES Modules 特性，从一开始规避这个问题。\n如果你实在希望使用 Vite 做开发，同时只能使用 file:///，可以使用 @vitejs/plugin-legacy 39 生成 nomodule 的版本，然后对 dist/index.html 做如下改动：\n\n移除 &lt;script type=module&gt; 元素\n移除其他 &lt;script&gt; 的 nomodule 属性\n移除 &lt;script id=vite-legacy-entry&gt; 元素的内容，并把 data-src 属性名改为 src\n移除 SystemJS loader 代码（那个压缩到一行的 &lt;script&gt;）\n修改所有资源地址为相对地址（例如把 /assets/index-legacy.xxxx.js 改为 ./assets/index-legacy.xxxx.js，注意还有 CSS 文件）\n\n我没有这么实践过，不确定所有功能都是正常的，建议部署前充分测试。\n\n","thumbnail":"https://picsum.photos/1280/720?random=10","color":"#111","plink":"https://fenglekai.github.io/2022/06/27/奇奇怪怪的坑/"},{"title":"常用的工具软件","date":"2022-06-27T01:01:18.000Z","date_formatted":{"ll":"2022年6月27日","L":"2022/06/27","MM-DD":"06-27"},"updated":"2023-02-22T03:53:30.010Z","content":"常用的工具软件\n\n\nVS Code\n\n\nGit\n\n\nNode\n\n\nSnipaste\n\n\nTypora\n\n\nPostman\n\n\nDBeaver\n\n\nVS Code常用插件\n\nVetur\nVue 2 Snippets\nVueHelper\nHTML CSS Support\nHTML Snippets\nJavaScript (ES6) code snippets\nnpm Intellisense\nPath Intellisense\nAuto Close Tag\nAuto Rename Tag\nBeautify\nBracket Pair Colorizer\nChinese (Simplified) (简体中文) Language Pack for Visual Studio Code\nESLint\nGitLens — Git Supercharged\n\n遇到的坑和问题\n\n\nsnipaste闪退：更换2.x的版本\n\n\nDBeaver在公司内部网络需要配置\n\n下载代理：窗口—首选项—驱动配置HTTP代理(用于下载)。\n下载驱动镜像：窗口—首选项—驱动—Maven，阿里云镜像：http://maven.aliyun.com/nexus/content/groups/public/\n全局的连接SQL代理：常规—网络连接，选择手工配置SOCKS模式的代理。\n\n\n\nnpm在公司内部网络需要配置代理\n\n\nVSCode插件Vetur设置\n页面代码中导入json文件Vetur会报错，需把Vetur在VSCode的settings.json配置以下字段\n1&quot;vetur.validation.script&quot;: false,\n","thumbnail":"https://picsum.photos/1280/720?random=9","color":"#111","plink":"https://fenglekai.github.io/2022/06/27/常用的工具软件/"},{"title":"npm代理设置","date":"2022-06-27T00:59:39.000Z","date_formatted":{"ll":"2022年6月27日","L":"2022/06/27","MM-DD":"06-27"},"updated":"2023-02-13T08:23:32.976Z","content":"npm代理设置\n12npm config set proxy http://127.0.0.1:8002npm config set https-proxy http://127.0.0.1:8002\nnpm有验证的代理设置\n12npm config set proxy http://username:password@127.0.0.1:8002npm confit set https-proxy http://username:password@127.0.0.1:8002\nnpm查看代理设置\n1npm config get or npm config list\nnpm删除代理设置\n1npm config delete proxy and npm config delete https-proxy\nnpx提示版本过旧，需要npm、yarn全局删除依赖\n12# 可能是因为npx的缓存问题，清除缓存就好了npx clear-npx-cache\n","thumbnail":"https://picsum.photos/1280/720?random=8","color":"#111","plink":"https://fenglekai.github.io/2022/06/27/npm代理设置/"},{"title":"MySQL初始化配置","date":"2022-06-27T00:59:22.000Z","date_formatted":{"ll":"2022年6月27日","L":"2022/06/27","MM-DD":"06-27"},"updated":"2023-02-13T07:34:07.829Z","content":"MySQL初始化配置\nD:\\mysql-8.0.27-winx64根目录下配置\n1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB\n设置环境变量（可能没效果）\n在path添加D:\\mysql-8.0.27-winx64\\bin目录\n管理员命令行进入mysql根目录下\n初始化数据库\n.\\mysqld --initialize --console\n执行完成会出现初始密码记得备份方便以后修改\nroot@localhost: APWCY5ws&amp;hjQ\n安装\n.\\mysql install\n启动和关闭mysql\nnet start mysql\nnet stop mysql\n登录\n.\\mysql -u root -p\n键入密码后执行更新密码，不然会一直提示你更新密码\nalter user 'root'@'localhost' identified by 'new password';\nflush privileges;\n更新一个问题\nmysql8之前的加密规则是mysql_native_password,而在mysql8之后，加密规则是caching_sha2_password.\n所以部分连接数据库会出现Client does not support authentication protocol requested by server\n查询方式\nselect host,user,plugin,authentication_string from mysql.user;\n解决办法\n\n更新你的连接服务加密方式\n修改mysql登录密码的加密规则\n\n修改加密规则\n12345alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;new password&#x27;;#更新user为root，host为%的密码为new password(自己设置)alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;new password&#x27;;#更新user为root,host为localhost 的密码为new password\nor\n1234alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;new password&#x27; password expire never;#修改加密规则alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;new password&#x27;;#更新一下用户的密码\nflush privileges; #刷新权限\n","thumbnail":"https://picsum.photos/1280/720?random=7","color":"#111","plink":"https://fenglekai.github.io/2022/06/27/MySQL初始化配置/"},{"title":"Git常用命令","date":"2021-12-06T14:43:43.000Z","date_formatted":{"ll":"2021年12月6日","L":"2021/12/06","MM-DD":"12-06"},"updated":"2023-02-14T03:52:01.366Z","content":"查看用户名和邮箱地址\ngit config user.name  git config user.email\n修改用户名和邮箱地址\ngit config --global user.name  &quot;xxxx&quot;   git config --global user.email  &quot;xxxx&quot;\n创建SSH密匙\nssh-keygen -t rsa -C &quot;（邮箱）&quot;\n克隆远程仓库\ngit clone\n暂存更改\ngit add .\n提交更改\ngit commit -m 'xxxx'\n查看提交文件是否修改\ngit status\n查看历史提交（目标版本）\ngit log\n查看所有分支\ngit branch -a\n切换分支\ngit checkout (分支名)\n从远程分支下载最新代码并合并\ngit pull (远程仓库名) (远程分支)\n从远程分支上传最新代码并合并\ngit push (远程仓库名) (远程分支)\n该选项可以合并两个独立启动仓库的历史\ngit pull origin master --allow-unrelated-histories\n新建远程仓库地址\ngit remote add &lt;远程仓库名&gt; &lt;远程仓库地址&gt;\n回退版本操作\ngit reset --hard &lt;目标版本&gt;\ngit checkout (分支名)\n提交时不会生成新的提交\ngit add .\ngit commit --amend\ngit push -f\n搁置当前修改\n1git stash\n重新回到被隐藏的更改处\n1git stash pop\n删除本地分支\n1git branch -D dev\n刷新分支\n1git remote update origin --prune\n打标签\n附注标签\n1git tag -a v1.0 -m &quot;my version 1.0&quot;\n查看标签\n1git show\n后期打标签\n1234# 查看过去提交commitgit log --pretty=oneline# 给commit打上标签git tag -a v1.0 commitkey\n删除标签\n1git tag -d v1.0\n","thumbnail":"https://picsum.photos/1280/720?random=5","color":"#111","plink":"https://fenglekai.github.io/2021/12/06/Git常用命令/"},{"title":"JavaScript学习笔记","date":"2021-12-06T14:43:02.000Z","date_formatted":{"ll":"2021年12月6日","L":"2021/12/06","MM-DD":"12-06"},"updated":"2023-02-13T07:34:07.829Z","content":"函数的调用\n简单点说，带括号的是函数调用，直接执行函数；不带括号的是绑定事件，事件触发再执行。\n复杂点说，带括号的是把返回值赋值给事件，不带括号的是把函数体所在地址位置赋值给事件。\n.then()方法是异步执行；当.then()前的方法执行完后再执行then()内部的程序，这样就避免了，数据没获取到等的问题\nPromise\nPromise 对象代表了未来将要发生的事件，用来传递异步操作的消息。\nPromise 对象有以下两个特点\n\n\n对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：\n\npending: 初始状态，不是成功或失败状态。\nfulfilled ( resolve ): 意味着操作成功完成。\nrejected: 意味着操作失败。\n\n只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。\n\n\n一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n\n解析数组对象\n\n通过.map()方法返回新数组，es6中只有一个形参可以不用括号， item =&gt; Object.values(item)map内的方法使用Object.values(item)，返回所有object对象中value的值。\n\nbind()\n方法会创建一个新的函数，称为绑定函数,fun方法在this环境下调用\n该方法可传入两个参数，第一个参数作为this，第二个及以后的参数则作为函数的参数调用\nwindow.location.href的用法\njavascript中的location.href有很多种用法，主要如下。\nself.location.href=“/url” 当前页面打开URL页面\nlocation.href=“/url” 当前页面打开URL页面\nwindows.location.href=“/url” 当前页面打开URL页面，前面三个用法相同。\nthis.location.href=“/url” 当前页面打开URL页面\nparent.location.href=“/url” 在父页面打开新页面\ntop.location.href=“/url” 在顶层页面打开新页面\n如果页面中自定义了frame，那么可将parent self top换为自定义frame的名称,效果是在frame窗口打开url地址\n此外，window.location.href=window.location.href;和window.location.Reload()和都是刷新当前页面。区别在于是否有提交数据。当有提交数据时，window.location.Reload()会提示是否提交，window.location.href=window.location.href;则是向指定的url提交数据\n你可以这么写： location.replace(location.href);\n一些通用方法\nwindow.open(url)\ntop.location.href=&quot;/url&quot;\n文件下载\n1234567891011121314151617181920// 文件链接直接下载const a = document.createElement(&quot;a&quot;);const url = &quot;url&quot;;const fileName = &quot;filename.xlsx&quot;;a.herf = url;a.download = fileName;a.click();// 后端blob流文件下载fetch(url).then((response) =&gt;  response.blob().then((blob) =&gt; &#123;    const a = document.createElement(&quot;a&quot;);    const url = window.URL.createObjectURL(blob);    const fileName = &quot;filename.xlsx&quot;;    a.herf = url;    a.download = fileName;    a.click();    window.URL.revokeObjectURL(url);  &#125;));\n返回并刷新页面：\nlocation.replace(document.referrer);\ndocument.referrer //前一个页面的URL\n不要用 history.go(-1)，或 history.back();来返回并刷新页面，这两种方法不会刷新页面。\n时间格式化\n12const value = new Date();const getDate = value.getFullYear() + &#x27;-&#x27; + (value.getMonth() + 1) + &#x27;-&#x27; + value.getDate() + &#x27; &#x27; + value.getHours() + &#x27;:&#x27; + value.getMinutes() + &#x27;:&#x27; + value.getSeconds();\n字符串转换数字，判断是否是数字\n123456// 数字加字母等非数字转换const s = &#x27;234string&#x27;;parseInt(s);　//234parseFloat(s);  //234.0isNaN() // 判断是否是数字，是返回true，否则返回false\n遍历对象\n1234567891011// 创建一个对象并指定其原型，bar 为原型上的属性const obj = Object.create(&#123; bar: &#x27;bar&#x27;&#125;) // foo 为对象自身的属性obj.foo = &#x27;foo&#x27; for (let key in obj) &#123; console.log(obj[key]) // foo, bar&#125;\nfor of是ES6新增的循环方法\n①：for of无法循环遍历对象\n②：遍历输出结果不同\n③：for in 会遍历自定义属性，for of不会\n数组中删除某个元素\n123456789101112//删除起始下标为1，长度为1的一个值(len设置1，如果为0，则数组不变) const arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]; arr.splice(1,1); console.log(arr); //[&#x27;a&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];     //删除起始下标为1，长度为2的一个值(len设置2) const arr2 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;] arr2.splice(1,2); console.log(arr2); //[&#x27;a&#x27;,&#x27;d&#x27;]\nsplit() 方法用于把一个字符串分割成字符串数组。\n在判断中 == ‘’ 会判断 0，''和undefinded\n深拷贝和浅拷贝\nJSON转换\n12const targetObj = JSON.parse(JSON.stringify(copyObj))let arr4 = JSON.parse(JSON.stringify(arr))\n缺点：\n\n如果对象里有函数,函数无法被拷贝下来\n无法拷贝copyObj对象原型链上的属性和方法\n当数据的层次很深，会栈溢出\n\n普通递归函数\n123456789101112131415161718function deepCopy( source ) &#123;if (!isObject(source)) return source; //如果不是对象的话直接返回    let target = Array.isArray( source ) ? [] : &#123;&#125; //数组兼容    for ( let k in source ) &#123;    \tif (source.hasOwnProperty(k)) &#123;    \t\tif ( typeof source[ k ] === &#x27;object&#x27; ) &#123;            \ttarget[ k ] = deepCopy( source[ k ] )        \t&#125; else &#123;            \ttarget[ k ] = source[ k ]        \t&#125;    \t&#125;    &#125;    return target&#125;function isObject(obj) &#123;    return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null&#125;\n缺点：\n\n无法保持引用\n当数据的层次很深，会栈溢出\n\n防栈溢出函数\n12345678910111213141516171819202122232425262728293031323334353637383940414243function cloneLoop(x) &#123;    const root = &#123;&#125;;    // 栈    const loopList = [        &#123;            parent: root,            key: undefined,            data: x,        &#125;    ];    while(loopList.length) &#123;        // 深度优先        const node = loopList.pop();        const parent = node.parent;        const key = node.key;        const data = node.data;        // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素        let res = parent;        if (typeof key !== &#x27;undefined&#x27;) &#123;            res = parent[key] = &#123;&#125;;        &#125;        for(let k in data) &#123;            if (data.hasOwnProperty(k)) &#123;                if (typeof data[k] === &#x27;object&#x27;) &#123;                    // 下一次循环                    loopList.push(&#123;                        parent: res,                        key: k,                        data: data[k],                    &#125;);                &#125; else &#123;                    res[k] = data[k];                &#125;            &#125;        &#125;    &#125;    return root;&#125;\n优点：\n\n不会栈溢出\n支持很多层级的数据\n\n1234567891011121314151617181920212223242526272829function copyObject(orig) &#123;   var copy = Object.create(Object.getPrototypeOf(orig));   copyOwnPropertiesFrom(copy, orig);   return copy; &#125; function copyOwnPropertiesFrom(target, source) &#123;   Object   .getOwnPropertyNames(source)   .forEach(function (propKey) &#123;     var desc = Object.getOwnPropertyDescriptor(source, propKey);     Object.defineProperty(target, propKey, desc);   &#125;);   return target; &#125; var obj = &#123;   name: &#x27;Jack&#x27;,   age: &#x27;32&#x27;,   job: &#x27;developer&#x27; &#125;; var obj2 = copyObject(obj); console.log(obj2); obj.age = 39; obj.name = &#x27;Tom&#x27;; console.log(obj); console.log(obj2);\n一些数据数据处理的方法\n123456789// string转numberparseInt(string); // 整型parseFloat(string); // 浮点型// 浮点数处理let num = &#x27;1.2345&#x27;Math.floor(num * 100) / 100; //向上取整Math.ceil(num * 100) / 100; // 向下取整Math.round(num * 100) / 100; // 四舍五入NumberObject.toFixed(num) //这里的num是指0~20的数字，用于保留小数后num位，如果不足会补0\n使用filter做批量勾选删除\n123let new_arr = attendeeList.filter(  (attendee) =&gt; selectedRowKeys.filter((key) =&gt; key === attendee.id).length === 0)\n数组上移下移操作\n12345678910111213141516171819202122up(index) &#123;            if(index === 0) &#123;              return            &#125;            //在上一项插入该项            this.list.splice(index - 1, 0, (this.list[index]))            //删除后一项            this.list.splice(index + 1, 1)            this.save();        &#125;,        down(index) &#123;            if (index === (this.list.length-1)) &#123;              return            &#125;            // 在下一项插入该项            this.list.splice(index + 2, 0, (this.list[index]))            // 删除前一项            this.list.splice(index, 1)            this.save();        &#125;,\n\n\n字母\n含义\n示例\n\n\n\n\ny\n年份。一般用 yy 表示两位年份，yyyy 表示 4 位年份\n使用 yy 表示的年扮，如 11；使用 yyyy 表示的年份，如 2011\n\n\nM\n月份。一般用 MM 表示月份，如果使用 MMM，则会根据语言环境显示不同语言的月份\n使用 MM 表示的月份，如 05；使用 MMM 表示月份，在 Locale.CHINA语言环境下，如“十月”；在 Locale.US语言环境下，如 Oct\n\n\nd\n月份中的天数。一般用 dd 表示天数\n使用 dd 表示的天数，如 10\n\n\nD\n年份中的天数。表示当天是当年的第几天， 用 D 表示\n使用 D 表示的年份中的天数，如 295\n\n\nE\n星期几。用 E 表示，会根据语言环境的不同， 显示不同语言的星期几\n使用 E 表示星期几，在 Locale.CHINA 语言环境下，如“星期四”；在 Locale.US 语言环境下，如 Thu\n\n\nH\n一天中的小时数（0~23)。一般用 HH 表示小时数\n使用 HH 表示的小时数，如 18\n\n\nh\n一天中的小时数（1~12)。一般使用 hh 表示小时数\n使用 hh 表示的小时数，如 10 (注意 10 有可能是 10 点，也可能是 22 点）\n\n\nm\n分钟数。一般使用 mm 表示分钟数\n使用 mm 表示的分钟数，如 29\n\n\ns\n秒数。一般使用 ss 表示秒数\n使用 ss 表示的秒数，如 38\n\n\nS\n毫秒数。一般使用 SSS 表示毫秒数\n使用 SSS 表示的毫秒数，如 156\n\n\nYYYY-MM-dd HH:mm:ss\n前端模糊查询\n12345678910111213141516171819202122//字符串方法indexOfvar len = list.length;var arr = [];for(var i=0;i&lt;len;i++)&#123;    //如果字符串中不包含目标字符会返回-1    if(list[i].indexOf(keyWord)&gt;=0)&#123;        arr.push(list[i]);    &#125;&#125;return arr;//正则表达式var len = list.length;var arr = [];var reg = new RegExp(keyWord);for(var i=0;i&lt;len;i++)&#123;    //如果字符串中不包含目标字符会返回-1    if(list[i].match(reg))&#123;        arr.push(list[i]);    &#125;&#125;return arr;\n1234567891011121314151617/*** @param &#123;Object&#125; lists 所有数据* @param &#123;Object&#125; keyWord 查询的关键词*/selectMatchItem(lists, keyWord) &#123;    let resArr = [];    lists.filter(item =&gt; &#123;        for(let i in item)&#123;            if (item[i].includes(keyWord)) &#123;                resArr.push(item);            &#125;        &#125;    &#125;)    return resArr;&#125;,// 函数执行 在 “staff” 对象中查找 包含 “coot” 的数据。this.selectMatchItem(staff,&#x27;coot&#x27;)\n","thumbnail":"https://picsum.photos/1280/720?random=4","color":"#111","plink":"https://fenglekai.github.io/2021/12/06/JavaScript学习笔记/"},{"title":"使用Typora+PicGo快速在Hexo博客上发布文章","date":"2021-11-30T15:07:35.000Z","date_formatted":{"ll":"2021年11月30日","L":"2021/11/30","MM-DD":"11-30"},"updated":"2023-02-13T07:34:07.829Z","content":"Typora第一版发布了也开始收费了，不过0.11版本还是可以用的，介意的朋友可以不看了哈~\n**历史版本的链接：**https://typora.io/windows/dev_release.html\n博客搭好了，接下来就是要发布文章啦~什么？你还没搭过博客？那你肯定没看过我快速搭建博客的教程。\n最近在参考我关注的一个b站up主鱼皮分享的一篇提升写作效率的文章。\n然后，我就开始踩坑了哈，开启我的分享之路。\n安装软件\n在你还在懵逼.md后缀是什么东西？它的语法怎么用？这时候已经有大佬帮你铺好路，你只需要下载软件直接开启你的写作之旅。\n我们先要安装Typora和PicGo，然后你就可以用Typora先熟悉一下界面，当你想在文章中插入图片时，这就需要另一个软件PicGo了。\nTypora和PicGo的配置\n这里踩个坑哈，之前跟着用七牛云的存储对象实现图片存储读取，但是！因为，本人比较懒，没有申请域名，刚在七牛云注册一个帐号就使用免费的空间和临时域名。在配置好后使用chrome访问页面图片发现加载不出来，后来才知道chrome会强制转换http为https…找了几个解决办法都没啥用。\n\n之后我就改用gitee图床了，这个搭建也是非常简单的，参考知乎一篇文章PicGo + Gitee(码云)实现markdown图床。\n首先在PicGo最下方插件设置安装gitee-uploader。\n\n等待安装的时候，我们可以先去gitee去新建一个仓库，如图设置好后创建。\n\n然后回到PicGo查看插件是否安装完成，完成后在图床设置找到gitee选项如图设置。\n\n\nrepo：新建仓库的部分路径，比如，我的是https://gitee.com/feng-lekai/blog-image，那我的repo就是feng-lekai/blog-image\nbranch：分支就不用我多说了吧~\ntoken：没用的小伙伴需要自己去右上角自己头像那找到设置-私人令牌生成新令牌，权限选择projects就行，然后生成令牌。记得复制哈，它只会显示一次，如果没复制成功就要重新生成了（小问题）。\npath：图片存储路径\n\n接着点击确定，设置默认图床就ok了，可以在PicGo上传区去上传图片试试啦~\n接着回到Typora菜单找到文件-偏好设置-图像，选择上传服务。\n\n设置好就可以在Typora随时插入图片啦，然后share你的文章~希望这篇文章对你有点帮助，致力于简洁快速的教程。\n","thumbnail":"https://picsum.photos/1280/720?random=3","color":"#111","plink":"https://fenglekai.github.io/2021/11/30/使用Typora-PicGo快速在Hexo博客上发布文章/"},{"title":"如何快速搭建一个博客","date":"2021-11-14T14:57:38.000Z","date_formatted":{"ll":"2021年11月14日","L":"2021/11/14","MM-DD":"11-14"},"updated":"2023-02-13T07:34:07.829Z","content":"写在前面\n​\t\t最近心血来潮的一个想法就是搭一个属于自己的博客，之前很多面试第一句话就是“你有自己的博客吗？”我只能尴尬的笑笑。在学校荒废的时间没有用来学习一些新的技术我很惭愧，但人嘛总要向前看，一些失败的经历，面临的坎坷总会让你更珍惜现下的生活。\n​\t\t博客相当于自己的第二份简历了，这里记录着你学习的过程，获得的成功（我还没有）。这篇文章将记录我自己搭建博客的过程以及一些坑。\n安装环境\n​\t\t搭建博客相当简单，仅需安装Node.js和Git，当然还要有一个GitHub的帐号。\n安装hexo\n在你喜欢的磁盘位置输入如下命令（建议新建一个文件夹，和构建Vue-cli模版差不多）：\nnpm install -g hexo-cli\nhexo init yourblogname\nyourblogname 是你想要创建文件夹的名字\ncd yourblogname\nnpm install\n启动本地环境\n命令行键入：\nhexo generate\nhexo server\n检查本地环境没问题就可以部署到github上啦\n部署步骤\n新建一个新的仓库，仓库名必须是用户名+.github.io注意哈！！踩个坑😇\n比如我的用户名是fenglekai，那我用于部署的仓库名就是fenglekai.github.io,这也是你之后访问的网址路径，其他配置默认就好，创建。\n配置_config.yml\n1234deploy:  type: git  repo: git@github.com:usrename/warehousename.github.io.git  branch: master\n这里网上的教程都是用http去deploy的我弄半天弄不好气死我了，每次都输入用户名密码错。还是用ssh免密登录舒服呀！记得去新建的仓库拷贝ssh（就是那个code clone的方式）。\n最后顺序用三个命令直接部署到github上，之后的修改文章再上传也是这个步骤：\nhexo clean\nhexo generate\nhexo deploy\n然后就是用仓库名去访问啦~\n默认的模版千篇一律，还是搞个主题有意思\n可以在hexo主题里找自己喜欢的模版然后\nnpm install 主题库\n在**_config.yml修改主题名,然后拷贝一份在同一目录下，文件名为_config.themename.yml**\n1theme: themename\n然后就可以配置属于自己的主题文档了。\nhexo的目录结构以及配置编写文章\n\npublic 静态文件存放\nscaffolds page页面和post文章默认配置\nsource posts文章和page页面编写及存放位置\nthemes 应该是主题吧，有些主题是直接拷贝的应该就是放在这里读取。\n\n大多数的配置都是在主题配置以及默认文章配置里的。这里说一下我现在用的markdowm编辑器Typora非常的简洁干净，支持的功能也非常多，推荐一下。\n最后就是最重要的新建文章命令啦hexo new postname\n更多的配置以及详细的图文介绍还是需要大家去多多查看官方文档和\n下面👇的教程推荐啦，结束！\n参考完整教程：hexo史上最全搭建教程\n","thumbnail":"https://picsum.photos/1280/720?random=2","color":"#111","plink":"https://fenglekai.github.io/2021/11/14/如何快速搭建一个博客/"},{"title":"React学习笔记","date":"2021-11-14T05:42:44.000Z","date_formatted":{"ll":"2021年11月14日","L":"2021/11/14","MM-DD":"11-14"},"updated":"2023-02-13T07:34:07.829Z","content":"用于构建用户界面的 JavaScript 库\nstate是当前组件的状态\nprops是获取父组件的state值\nclass类里，this指向当前类内的内容。例如this.state指向当前类的state状态；this.function指向当前类的方法。\nAntDesignPro\n使用Ant Design pro脚手架官网来搭建项目，其中最重要的三个文件夹，services、models、mock、pages\n\n\nsevices：数据接口\n\n\nmodels：数据处理\n\n\nmock：模拟数据\n\n\npages：页面\n\n\npages触发models中的方法来处理数据，若为异步操作在models中需要调用services中的数据接口方法，在后台未写完时可以通过mock中的模拟数据来调试\n具体来说，也即是使用dva时，**数据流向或者说触发流程为：**在pages中的jsx文件中通过dispatch触发models中的js文件中的effects或者reducers中的方法，其中effects中的方法是异步操作，通过yield call(调用接口函数方法名)调用从services中js文件引入的定义好的调用接口方法，然后通过yield put({type: ‘reduceres中的方法’})；来触发 reducers中的方法来修改state。\n组件生命周期\ncomponentWillMount 在渲染前调用,在客户端也在服务端。\ncomponentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。\ncomponentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。\ngetDerivedStateFromProps componentWillReceiveProps的替换方案。React相当于把componentWillReceiveProps拆分成getDerivedStateFromProps和componentDidUpdate。\nshouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。\n可以在你确认不需要更新组件时使用。\ncomponentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。\ncomponentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。\ncomponentWillUnmount在组件从 DOM 中移除之前立刻被调用。\nHook\n在这里，useState 就是一个 Hook （等下我们会讲到这是什么意思）。通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function DetailQuery(props) &#123;    const &#123; clickDetailQueryBtn, clickDetailResetBtn &#125; = props;    const [statu, setStatu] = useState(&#123; getstatu: &#x27;全部&#x27; &#125;);    const updateState = partialState =&gt;        setStatu(oldState =&gt; (&#123;            ...oldState,            ...partialState        &#125;));        return (        &lt;Layout&gt;            &lt;Row                style=&#123;&#123;background: &#x27;white&#x27;, paddingTop: 20, paddingRight: 20, paddingBottom: 20&#125;&#125;            &gt;                &lt;Col span=&#123;6&#125; className=&#123;styles.formItemClass&#125;&gt;                    状态：                    &lt;Select                     // defaultValue=&quot;全部&quot;                     style=&#123;&#123; width: 120 &#125;&#125;                     value=&#123;statu.getstatu&#125;                    onChange=&#123;e =&gt; &#123;                        updateState(&#123; getstatu: e &#125;);&#125; &#125;                    &gt;                        &lt;Select.Option value=&quot;全部&quot;&gt;全部&lt;/Select.Option&gt;                        &lt;Select.Option value=&quot;待上报&quot;&gt;待上报&lt;/Select.Option&gt;                        &lt;Select.Option value=&quot;待审核&quot;&gt;待审核&lt;/Select.Option&gt;                        &lt;Select.Option value=&quot;已通过&quot;&gt;已通过&lt;/Select.Option&gt;                        &lt;Select.Option value=&quot;未通过&quot;&gt;未通过&lt;/Select.Option&gt;                    &lt;/Select&gt;                &lt;/Col&gt;                &lt;Col push=&#123;1&#125; span=&#123;6&#125;&gt;                    &lt;Button                        type=&quot;primary&quot;                        style=&#123;&#123;marginRight: 7&#125;&#125;                        onClick=&#123;() =&gt; &#123;                            clickDetailQueryBtn(statu);                        &#125;&#125;                    &gt;                        查询                    &lt;/Button&gt;                    &lt;Button                        onClick=&#123;() =&gt; &#123;                            clickDetailResetBtn(&#x27;&#x27;);                        &#125;&#125;                        // onClick=&#123;this.props.clickDetailResetBtn&#125;                    &gt;                        重置                    &lt;/Button&gt;                &lt;/Col&gt;            &lt;/Row&gt;        &lt;/Layout&gt;    );&#125;\nRouter\n12345678910111213141516171819202122232425262728// 审核和重新审核export async function toExamineReport(params) &#123;    return request(Api.toExamineReport, &#123;         method: &#x27;POST&#x27; ,        body: &#123;            ...params        &#125;    &#125;)&#125;// 查看上报记录export async function getMyCorrectionReportQueryRecord(params) &#123;    return request(Api.getMyCorrectionReportQueryRecord + `?$&#123;stringify(params)&#125;`, &#123;         method: &#x27;GET&#x27; ,        // body: &#123;        //     ...params        // &#125;    &#125;)&#125;// 批量下载整改报告附件export async function onPatchExport(params) &#123;    return request(Api.onPatchExport + `?$&#123;stringify(params)&#125;`, &#123;         method: &#x27;GET&#x27; ,        responseType: &#x27;blob&#x27;, // 下载文件        // body: &#123;        //     ...params        // &#125;    &#125;)&#125;\nreact-devtools\n\n× Install fail! Error: Unsupported URL Type: link:./scripts/eslint-rules\n\n安装出错，需要把3个文件中的link改成file\n\n12link:./scripts/eslint-rules // 改前file:./scripts/eslint-rules // 改后\n安装教程\n\nhttps://blog.csdn.net/one_girl/article/details/80916232\n\nTypeError: Cannot read property ‘split’ of null\nstr.split(‘.’)\n变成\n(str || “”).split(‘.’)\n不报错啦\nrouterRedux路由跳转\n123456789101112import router from &#x27;umi/router&#x27;;import &#123; routerRedux &#125; from &#x27;dva/router&#x27;;    this.props.dispatch(routerRedux.push(&#123;       pathname : &#x27;/partyBuildingDebriefing/debriefingMeeting/meetingStaffManagement&#x27;,       record:&#123;        detailVisibel: true,         detailProps: &#123;          title: &#x27;编辑述职会议及人员信息&#x27;&#125;,        id: this.props.id      &#125;     &#125;))\nAntd Table 合并某列单元格方法\n须传输出值text，和索引值index\n12345678910111213141516171819// 合并单元格操作threeCell = (text, index) =&gt; &#123;  // 在render中所有的合并都仅仅相对所有的name这一列来说，index从0开始计算  const obj = &#123;      children: index+1,      props: &#123;&#125;  &#125;;  // 3个单元格取余  let i = index%3;  // index=0：相对name这一列，合并3列单元格  if (i === 0) &#123;      obj.props.rowSpan = 3;  &#125;  // 合并单元格后，则第1行渲染，第2，3行不渲染  if (i &gt; 0 &amp;&amp; i &lt;3) &#123;      obj.props.rowSpan = 0;  &#125;  return obj&#125;\nInput组件onChange事件获取value值\n1234onChange = e =&gt; &#123;    const value = e.target.value;    console.log(value);&#125;\n表单获取用户输入基本格式\n123456&lt;FormItem label=&#x27;颁奖日期&#x27;&gt; &#123;form.getFieldDecorator(&#x27;字段名&#x27;, &#123;   initialValue: &#x27;默认值&#x27;,   rules: [&#123; message: &#x27;规则字段&#x27;, &#125;] &#125;)(&lt;Input placeholder=&#x27;页面渲染输入框&#x27;/&gt;)&#125;&lt;/FormItem&gt;\n重置表单验证保留输入值\n1234// 重置表单tenderStatus属性的值以及表单验证提示（值会变成initialValue的值）this.props.form.resetFields([&#x27;tenderStatus&#x27;]);// 将我们重置之前储存好的属性值，给联动表单的属性重新赋值，否则会变成initialValue的值this.props.form.setFieldsValue(&#123; tenderStatus: status &#125;);\nAntd中DatePicker组件在3.x及以下版本\n在使用mode属性API后选择日期没有反应，需要使用onPanelChange属性和onOpenChange属性改变open属性。\ndisabledDate属性没有效果，无法禁用相应年份，月份，只能禁用日期。可以在选择年份时判断当前日期与预期日期符不符合用message反馈给用户。\nAntd 给TableCell 添加key属性方法\n1234// 自动生成keygenerateRandomId = (length) =&gt; &#123;// length是你的id的长度，可自定义  return Math.random().toString(36).substr(3,length);&#125;\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n123456789101112131415import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;function Example() &#123;  const [count, setCount] = useState(0);  // Similar to componentDidMount and componentDidUpdate:    useEffect(() =&gt; &#123;    // Update the document title using the browser API    document.title = `You clicked $&#123;count&#125; times`;  &#125;);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;\nuseState: 对应class中state,比其更加强大：对应变量自带方法setState解决复杂的逻辑问题。\nuseEffect:对应class中ComponentDidMount初始化渲染，属于副作用操作。\n","thumbnail":"https://picsum.photos/1280/720?random=1","color":"#111","plink":"https://fenglekai.github.io/2021/11/14/React学习笔记/"},{"title":"about","date":"2021-11-20T07:07:59.000Z","date_formatted":{"ll":"2021年11月20日","L":"2021/11/20","MM-DD":"11-20"},"updated":"2023-02-13T07:34:07.841Z","content":"\n关于我，一名在努力变得不平凡的人\n\n","plink":"https://fenglekai.github.io/about/"}]